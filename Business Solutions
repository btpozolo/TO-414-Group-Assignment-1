library(dtplyr)
df <- data.table(A=1:5, B=c("Eric" , "Blake", "Sam", "Fred", "Roger"))
test <- data.frame(names = c("Blake", "Eric", "Blake", "Blake", "Sam", "Fred"))
test$hour <- c(1,1,1,2,2,2)

df$C <- sum(test$names == "Blake")  #adds new column based on filter, need to replace blake with previous column


#Problem 1: stations to increase capacity


#Problem 2: identifying if certain bikes are taking up more of maintenance
#Grouping by bikeID
by.id <- test %>%
  group_by(bikeid) %>%
  summarise(total.duration = sum(tripduration), num.uses = n())

#Take smaller sample of data so plots are readable
sample <- sample_n(by.id, 100)

#Number of Uses
#Mean and Medain pretty similar for number of uses
summary(sample$num.uses)
hist(sample$num.uses, 100, col="black")
qqnorm(sample$num.uses);qqline(sample$num.uses, col = 2)
shapiro.test(sample$num.uses)

#Total Trip Distance 
#Strong skew of data to right
summary(sample$total.duration)
hist(sample$total.duration, 100, col="black")
qqnorm(sample$total.duration);qqline(sample$total.duration, col = 2)
shapiro.test(sample$total.duration)

#Plot of trip Duration  by bikeID
max <- max(by.id$total.duration) #to try to set this as upper bound of graph
by.id <- by.id[order(by.id$total.duration, decreasing = T), ]  # sort
by.id$bikeid <- factor(by.id$bikeid, levels = by.id$bikeid)  # to retain the order in plot.
ggplot(by.id, aes(by.id$bikeid, by.id$total.duration)) + geom_bar(stat="identity") + ylim(0, 200000) #need to redo upper limit and maybe plot the average line

#Plot of NumTrips  by bikeID (can be used with full data)
by.id <- by.id[order(by.id$num.uses, decreasing = T), ]  #sort (can delete)
qplot(num.uses, data=by.id, geom="histogram", binwidth=1, main = "Number of Trips per Bike", xlab = "Number of Trips", ylab = "Number of Bikes")
